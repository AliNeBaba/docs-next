# Экземпляр приложения

## Создание экземпляра

Каждое приложение начинается с создания нового **экземпляра приложения** с помощью функции `createApp`:

```js
Vue.createApp(/* опции */)
```

После создания экземпляра мы можем _примонтировать_ его, передав элемент-контейнер в метод `mount`. Например, если мы хотим примонтировать приложение Vue в `<div id="app"></div>`, необходимо передать `#app`:

```js
Vue.createApp(/* опции */).mount('#app')
```

Хоть Vue и не реализует [паттерн MVVM](https://ru.wikipedia.org/wiki/Model-View-ViewModel) в полной мере, архитектура фреймворка им во многом вдохновлена. Поэтому переменную с экземпляром приложения традиционно именуют `vm` (сокращённо от ViewModel).

При создании экземпляра необходимо передать **объект опций**. Большая часть этого руководства посвящена описанию, как можно использовать эти опции для достижения желаемого поведения. Полный список опций можно посмотреть в [справочнике API](../api/options-data.md).

Приложение Vue состоит из **корневого экземпляра**, создаваемого с помощью `createApp`, опционально организованного в дерево вложенных, повторно используемых компонентов. Например, дерево компонентов для приложения TODO-списка может выглядеть так:

```
Корневой экземпляр
└─ TodoList
   ├─ TodoItem
   │  ├─ DeleteTodoButton
   │  └─ EditTodoButton
   └─ TodoListFooter
      ├─ ClearTodosButton
      └─ TodoListStatistics
```

Подробнее о [системе компонентов](component-basics.md) мы поговорим позднее. А сейчас запомните, что все компоненты Vue также являются экземплярами и поэтому принимают такой же объект опций.

## Данные и методы

Когда экземпляр создан, он добавляет все свойства, найденные в опции `data`, в [**систему реактивности** Vue](reactivity.md). Поэтому представление будет «реагировать» на их изменения, обновляясь в соответствии с новыми значениями.

```js
// Наш объект data
const data = { a: 1 }

// Объект добавляется в корневой экземпляр
const vm = Vue.createApp({
  data() {
    return data
  }
}).mount('#app')

// Получение свойства из экземпляра
// возвращает то же значение из исходных данных
vm.a === data.a // => true

// Изменение свойства экземпляра
// влияет на оригинальные данные
vm.a = 2
data.a // => 2
```

Когда значения изменяются, представление будет отрисовано заново. Но обратите внимание, свойства в `data` будут **реактивными**, только если они существовали при создании экземпляра. Это значит, если добавить новое свойство, например:

```js
vm.b = 'hi'
```

То изменения в `b` не будут вызывать никаких обновлений. Если вы знаете, что свойство вам понадобится позже, но изначально оно пустое или несуществующее, нужно просто установить начальное значение. Например:

```js
data() {
  return {
    newTodoText: '',
    visitCount: 0,
    hideCompletedTodos: false,
    todos: [],
    error: null
  }
}
```

Единственным исключением здесь является использование `Object.freeze()`, который предотвращает изменение существующих свойств, что также означает невозможность _отслеживать_ изменения системой реактивности.

```js
const obj = {
  foo: 'bar'
}

Object.freeze(obj)

const vm = Vue.createApp({
  data() {
    return obj
  }
}).mount('#app')
```

```html
<div id="app">
  <p>{{ foo }}</p>
  <!-- мы теперь не можем обновить `foo`! -->
  <button v-on:click="foo = 'baz'">Изменить</button>
</div>
```

Кроме свойств объекта `data`, экземпляры предоставляют ряд служебных свойств и методов экземпляра. Их имена начинаются с префикса `$`, чтобы отличаться от пользовательских свойств. Например:

```js
const vm = Vue.createApp({
  data() {
    return {
      a: 1
    }
  }
}).mount('#example')

vm.$data.a // => 1
```

С полным списком свойств и методов экземпляра можно ознакомиться в [справочнике API](../api/instance-properties.md).

## Хуки жизненного цикла экземпляра

Каждый экземпляр при создании проходит через последовательность шагов инициализации — например, настраивает наблюдение за данными, компилирует шаблон, монтирует экземпляр в DOM, обновляет DOM при изменении данных. Между этими шагами вызываются функции, называемые **хуками жизненного цикла**, с помощью которых можно выполнять свой код на определённых этапах.

Например, хук [`created`](../api/options-lifecycle-hooks.md#created) можно использовать для выполнения кода после создания экземпляра:

```js
Vue.createApp({
  data() {
    return {
      a: 1
    }
  },
  created() {
    // `this` указывает на экземпляра vm
    console.log('a is: ' + this.a) // => "a is: 1"
  }
})
```

Существуют и другие хуки, вызываемые на различных стадиях жизненного цикла экземпляра, например [`mounted`](../api/options-lifecycle-hooks.md#mounted), [`updated`](../api/options-lifecycle-hooks.md#updated) и [`destroyed`](../api/options-lifecycle-hooks.md#destroyed). Все хуки вызываются с контекстной переменной `this`, ссылающейся на текущий активный экземпляр вызывающий его.

:::tip Совет
Не используйте [стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions) в свойствах экземпляра и в коллбэках, например `created: () => console.log(this.a)` или `vm.$watch('a', newVal => this.myMethod())`. Так как стрелочные функции не имеют собственного `this`, то `this` в коде будет обрабатываться как любая другая переменная и её поиск будет производиться в областях видимости выше до тех пор пока не будет найдена, часто приводя к таким ошибкам, как `Uncaught TypeError: Cannot read property of undefined` или `Uncaught TypeError: this.myMethod is not a function`.
:::

## Диаграмма жизненного цикла

Ниже представлена диаграмма жизненного цикла экземпляра. Необязательно понимать её полностью прямо сейчас, но по мере изучения и практики разработки к ней полезно будет обращаться.

<img src="/images/lifecycle.png" width="840" height="auto" style="margin: 0px auto; display: block; max-width: 100%;" loading="lazy" alt="Хуки жизненного цикла экземпляра">
