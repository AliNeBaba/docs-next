# Структура исходного кода

## Избегайте синглтонов с состоянием

При написании кода только для клиентской стороны можно быстро привыкнуть, что код каждый раз выполняется в новом контексте. Но сервер Node.js — длительный процесс. Поэтому когда код впервые импортируется процессом, он будет выполнен один раз, а затем останется в памяти. Это означает, что если создать объект синглтон, то он станет использоваться для всех входящих запросов, что чревато загрязнением состояния при перекрёстных запросах.

Поэтому, требуется **создавать новый корневой экземпляр Vue для каждого запроса.** Чтобы сделать это, нужно написать функцию-фабрику, которая сможет многократно выполняться для создания свежих экземпляров приложения для каждого запроса:

```js
// app.js
const { createSSRApp } = require('vue')

function createApp() {
  return createSSRApp({
    data() {
      return {
        user: 'Василий Пупкин'
      }
    },
    template: `<div>Текущий пользователь: {{ user }}</div>`
  })
}
```

Код серверной части теперь становится таким:

```js
// server.js
const { renderToString } = require('@vue/server-renderer')
const server = require('express')()
const { createApp } = require('src/app.js')

server.get('*', async (req, res) => {
  const app = createApp()

  const appContent = await renderToString(app)
  const html = `
  <html>
    <body>
      <h1>Мой первый заголовок</h1>
      <div id="app">${appContent}</div>
    </body>
  </html>
  `

  res.end(html)
})

server.listen(8080)
```

Это правило также применяется и к экземплярам роутера (router) или хранилища (store). Вместо того, чтобы непосредственно экспортировать их из модуля и импортировать в приложении, теперь нужно создавать новый экземпляр в `createApp` и внедрять его из корневого экземпляра Vue.

## Добавление шага сборки

До сих пор, ещё не обсуждали каким образом доставлять клиенту такое приложение Vue. Чтобы сделать это, потребуется собрать приложение с использованием webpack.

- Требуется обработать серверный код с помощью webpack. Например, файлы `.vue` нужно обработать с помощью `vue-loader`, а многие специфические для webpack функции, такие как импорт файлов через `file-loader` или импорт CSS через `css-loader`, не будут работать напрямую в Node.js.

- Аналогично, нужна отдельная сборка для клиентской стороны, потому несмотря на то, что последняя версия Node.js полностью поддерживает возможности ES2015, для старых браузеров необходимо транспилировать код.

Основная идея заключается в том, что webpack будет использоваться для сборки приложения как для клиента, так и для сервера. Серверная сборка будет необходима на сервере и использоваться для отрисовки статического HTML, а клиентская сборка будет отправляться в браузер для гидратации статической разметки.

![архитектура](https://cloud.githubusercontent.com/assets/499550/17607895/786a415a-5fee-11e6-9c11-45a2cfdf085c.png)

Подробности настройки обсудим в следующих разделах — а сейчас, давайте представим, что уже разобрались с настройкой сборки и можем писать код приложения Vue с использованием webpack.

## Структура кода с webpack

Теперь, когда используем webpack для сборки приложения как для сервера, так и для клиента, большая часть исходного кода может быть написана универсально, с доступом ко всем возможностям webpack. В то же время есть ряд вещей, о которых следует помнить при [написании универсального кода](universal.md).

Простой проект может выглядеть так:

```bash
src
├── components
│   ├── MyUser.vue
│   └── MyTable.vue
├── App.vue
├── app.js # универсальная точка входа
├── entry-client.js # запускается только в браузере
└── entry-server.js # запускается только на сервере
```

### `app.js`

`app.js` — универсальная точка входа приложения. В клиентской части приложения, прямо в этом файле создавался бы корневой экземпляр приложения Vue и монтировался непосредственно в DOM. Однако, при использовании SSR эта ответственность переносится в файл клиентской точки входа (`entry-client.js`). Вместо этого `app.js` создаёт экземпляр приложения и экспортирует его:

```js
import { createSSRApp } from 'vue'
import App from './App.vue'

// экспортируем функцию фабрику для создания корневого компонента
export default function(args) {
  const app = createSSRApp(App)

  return {
    app
  }
}
```

### `entry-client.js`

Клиентская точка входа создаёт приложение, используя фабрику корневых компонентов, и монтирует его в DOM:

```js
import createApp from './app'

// логика инициализации, специфичная для клиента...

const { app } = createApp({
  // здесь можно передать фабрика приложений дополнительные аргументы
})

// это предполагает, что в шаблоне App.vue корневой элемент будет с `id="app"`
app.mount('#app')
```

### `entry-server.js`

Серверная точка входа использует экспорт по умолчанию, который представляет собой функцию, вызываемую многократно для каждой отрисовки. На данный момент, она не делает ничего, кроме возврата экземпляра приложения, но позднее здесь добавится серверное сопоставление маршрутов и логику предварительной загрузки данных.

```js
import createApp from './app'

export default function() {
  const { app } = createApp({
    /*...*/
  })

  return {
    app
  }
}
```
