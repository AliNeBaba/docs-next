# Написание универсального кода

Прежде чем продолжить, давайте обсудим ограничения при написании «универсального» кода — т.е. кода, который работает как на сервере, так и на клиенте. Из-за различий в сценариях использования и API платформ поведение кода не будет абсолютно одинаковым  при работе в разных окружениях. В этом разделе рассмотрены основные моменты, о которых следует знать.

## Реактивность данных на сервере

В приложениях, работающих только на стороне клиента, каждый пользователь будет использовать свежий экземпляр приложения в своём браузере. Для отрисовки на стороне сервера может захотеться того же: чтобы каждый запрос получал свежий, изолированный экземпляр приложения, чтобы не происходило загрязнения состояния между запросами.

Поскольку фактический процесс отрисовки должен быть детерминированным, данные на сервере будут также «предварительно загружаться» — это означает, что состояние приложения уже будет определено, когда начнётся отрисовка. Также это означает, что реактивность данных на сервере не нужна, поэтому она отключена по умолчанию. Отключение реактивности также позволяет избежать затрат производительности на преобразование данных в реактивные объекты.

## Хуки жизненного цикла компонента

Так как динамических обновлений не будет, то во время SSR будут вызываться лишь [хуки жизненного цикла](../instance.md#хуки-жизненного-цикла) `beforeCreate` и `created`. Это означает, что любой код в других хуках жизненного цикла, таких как `beforeMount` или `mounted`, будет выполняться только на клиенте.

Ещё одно замечание: следует избегать кода, который производит глобальные побочные эффекты в `beforeCreate` или `created`, например, установку таймеров с помощью `setInterval`. В клиентском коде можно установить таймер, а затем уничтожить его в `beforeUnmount` или `unmounted`. Однако, поскольку хуки уничтожения не будут вызваны во время SSR, таймеры останутся навсегда. Чтобы избежать этого, перенесите код побочного эффекта в `beforeMount` или `mounted`.

## Доступ к API, специфичным для конкретной платформы

Универсальный код не может предлагать доступ к API, специфическим для платформы, поэтому если в коде напрямую используются глобальные значения только для браузера, такие как `window` или `document`, то при выполнении в Node.js они будут вызывать ошибки, и наоборот.

Для задач, общих для сервера и клиента, но использующих API различных платформ, рекомендуется оборачивать специфические для платформы реализации в универсальный API или использовать библиотеки, которые это делают самостоятельно. Например, [axios](https://github.com/axios/axios) — HTTP-клиент, который предоставляет одинаковый API как для работы на сервере, так и для работы на клиенте.

Для API, предназначенных только для браузера, распространённым подходом является ленивый доступ к ним внутри хуков жизненного цикла, предназначенных только для клиента.

Обратите внимание, что если сторонняя библиотека не написана с учётом универсального использования, то может быть проблемой интегрировать её в приложение с отрисовкой на стороне сервера. Конечно _можно_ попробовать заставить её работать, создавая моки для некоторых глобальных свойств, но это будет грязным хаком и может помешать коду для определения окружения в других библиотеках.

## Пользовательские директивы

Большинство [пользовательских директив](../custom-directive.md) непосредственно манипулируют DOM, поэтому будут вызывать ошибки во время SSR. Рекомендуем в таких случаях предпочесть использование компонентов в качестве механизма абстракции, вместо директив.
